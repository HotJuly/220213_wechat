# 组件懒加载

1. 前言
   1. 假设现在有一个Vue项目,如果以生产环境打包项目,最终dist文件夹中会有几个文件?
      1. index.html
      2. index.js
      3. 如果项目中存在图片
         1. 图片体积较小的情况,图片会以base64格式编译,最终写入src中
         2. 图片体积较大的情况,图片就会被存放入images文件夹中单独存放
         3. 小总结:也就是说绝大多数的代码内容都会存放在index.js中
      4. 如果此时Vue项目具有10个组件文件,每个大小为1MB,最终代码都会在index.js中,.所以他的体积会是10MB
         1. 如果用户现在以网速1MB/s请求该网站,index.js文件需要请求10s,在这十秒钟内,页面一直处于白屏状态
         2. 想要的效果,用户看哪个页面就加载哪一个页面
2. ES6模块化语法
   1. import ... from ...
      1. 称为静态引入
      2. 在项目上线之后,文件中的该类语法都会被源文件内容所替代,也就是说项目上线之后,不存在该语法
      3. 如果项目中只是用这个语法,那么最终整个项目就会变成一个index.js文件
   2. import()
      1. 称为动态引入
      2. 在项目上线之后,文件中的该类语法会保留,使用这种语法引入的文件都会被单独切割成1个js文件,存储于服务器上
      3. 原理:webpack在打包过程中,如果遇到了import()语法,被引入的文件就会自动变为一个单独的js文件
      4. 如果项目中使用该语法,最终整个项目文件数量为1+1+9=11个文件
         1. index.html
         2. index.js
         3. 其余的9个组件文件
3. 组件懒加载的优点
   1. 由于项目中组件的代码都被使用import()语法进行切割,所以当用户请求网页时候,index.js文件的体积变小,那么所需要使用到的**带宽变小,加载速度变快,代码解析速度变快,首页渲染速度变快,首页白屏时间变短**
   2. 可以实现需要使用代码时,再发送请求操作
4. 组件懒加载的缺点
   1. 原先index.js中具有10个组件的代码,如果首次加载结束之后,每次切换后续其他页面都是秒加载
   2. 但是现在使用了组件懒加载之后,项目文件变多,当需要展示后续页面时,需要发送请求请求代码,页面需要等待文件数据返回,页面会进入白屏状态,也就是说懒加载之后,**后续页面渲染速度变慢,后续页面白屏时间变长**
5. 组件预加载
   1. 当用户已经看到页面之后,趁着用户不注意,偷偷加载未来可能使用的代码
   2. 优点:解决了组件懒加载的缺点,当用户跳转其余后续页面的时候,该页面的代码已经提前请求回来存放在内存中了
   3. 缺点:比较浪费用户的流量
   4. 原理:提前使用src或者.get请求将该文件请求到内存中进行存放
   5. Vue-cli中自带组件预加载功能优化